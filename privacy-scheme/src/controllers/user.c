/**
 *
 *  Copyright (C) 2020  Raul Casanova Marques
 *
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "user.h"

/**
 * Gets the user identifier.
 *
 * @param reader the reader to be used
 * @param identifier the user identifier
 * @return 0 if success else -1
 */
int ue_get_user_identifier(reader_t reader, user_identifier_t *identifier)
{
    if (identifier == NULL)
    {
        return -1;
    }

    memcpy(identifier->buffer, (uint8_t[]) {
            0x1b, 0x47, 0xfc, 0x5b, 0x81, 0x77, 0xf6, 0x7e,
            0x3f, 0x57, 0x62, 0xf5, 0x75, 0x2a, 0x7a, 0x3b,
            0x07, 0x25, 0x5b, 0x84, 0xe0, 0x54, 0x26, 0x87,
            0x16, 0x2d, 0x79, 0x36, 0xac, 0x32, 0x87, 0xbd
    }, USER_MAX_ID_LENGTH);
    identifier->buffer_length = USER_MAX_ID_LENGTH;

    return 0;
}

/**
 * Sets the user identifier and the issuer signatures of the user's keys.
 *
 * @param reader the reader to be used
 * @param identifier the user identifier
 * @param ie_signature the issuer signature
 * @return 0 if success else -1
 */
int ue_set_user_identifier_issuer_signatures(reader_t reader, user_identifier_t identifier, issuer_signature_t ie_signature)
{
    return 0;
}

/**
 * Computes the proof of key of the user keys.
 *
 * @param reader the reader to be used
 * @param sys_parameters the system parameters
 * @param ie_signature the issuer signature
 * @param nonce the nonce generated by the verifier
 * @param nonce_length the length of the nonce
 * @param ue_identifier the user identifier
 * @param proof_of_key the proof of key to be computed by the user
 * @return 0 if success else -1
 */
int ue_compute_proof_of_key(reader_t reader, system_par_t sys_parameters, issuer_signature_t ie_signature, const void *nonce, size_t nonce_length,
                            user_identifier_t ue_identifier, user_proof_of_key_t *proof_of_key)
{
    mclBnFr identifier;

    mclBnFr mul_result;
    mclBnG1 mul_result_g1;

    mclBnFr tau, rho, rho_id;

    mclBnG1 key_hat_prime;
    mclBnG1 t;

    /*
     * IMPORTANT!
     *
     * We are using SHA1 on the Smart Card. However, because the length
     * of the SHA1 hash is 20 and the size of Fr is 32, it is necessary
     * to enlarge 12 characters and fill them with 0's.
     */
    unsigned char hash[SHA_DIGEST_PADDING + SHA_DIGEST_LENGTH] = {0};
    SHA_CTX ctx;

    int r;

    if (nonce == NULL || nonce_length == 0 || proof_of_key == NULL)
    {
        return -1;
    }

    // set identifier to Fr mcl type
    mcl_bytes_to_Fr(&identifier, ue_identifier.buffer, EC_SIZE); // convert to mcl type

    /// tau and rho random numbers
    // tau
    mclBnFr_setByCSPRNG(&tau);
    r = mclBnFr_isValid(&tau);
    if (r != 1)
    {
        return -2;
    }

    // rho
    mclBnFr_setByCSPRNG(&rho);
    r = mclBnFr_isValid(&rho);
    if (r != 1)
    {
        return -3;
    }

    // rho_id
    mclBnFr_setByCSPRNG(&rho_id);
    r = mclBnFr_isValid(&rho_id);
    if (r != 1)
    {
        return -4;
    }

    /// signatures
    // key_hat
    mclBnG1_mul(&proof_of_key->key_hat, &ie_signature.user_key, &tau);
    mclBnG1_normalize(&proof_of_key->key_hat, &proof_of_key->key_hat);
    r = mclBnG1_isValid(&proof_of_key->key_hat);
    if (r != 1)
    {
        return -5;
    }

    // key_hat_prime
    mclBnG1_mul(&key_hat_prime, &ie_signature.user_key_prime, &tau);
    mclBnG1_normalize(&key_hat_prime, &key_hat_prime);
    r = mclBnG1_isValid(&key_hat_prime);
    if (r != 1)
    {
        return -6;
    }

    /// t values
    // t
    mclBnG1_mul(&t, &sys_parameters.G1, &rho); // t = G1·rho
    mclBnG1_mul(&mul_result_g1, &key_hat_prime, &rho_id); // mul_result_g1 = key_hat_prime·rho_id
    mclBnG1_add(&t, &t, &mul_result_g1); // t = t + mul_result_g1 (G1·rho + user_key_prime·rho_id)
    mclBnG1_normalize(&t, &t);
    r = mclBnG1_isValid(&t);
    if (r != 1)
    {
        return -7;
    }

#ifndef NDEBUG
    mcl_display_G1("key_hat", proof_of_key->key_hat);
    mcl_display_G1("t", t);
#endif

    /// e <-- H(...)
    SHA1_Init(&ctx);
    SHA1_Update(&ctx, &proof_of_key->key_hat, sizeof(mclBnG1));
    SHA1_Update(&ctx, &t, sizeof(mclBnG1));
    SHA1_Update(&ctx, nonce, nonce_length);
    SHA1_Final(&hash[SHA_DIGEST_PADDING], &ctx);

    /*
     * IMPORTANT!
     *
     * We are using SHA1 on the Smart Card. However, because the length
     * of the SHA1 hash is 20 and the size of Fr is 32, it is necessary
     * to enlarge 12 characters and fill them with 0's.
     */
    mcl_bytes_to_Fr(&proof_of_key->e, hash, EC_SIZE);
    r = mclBnFr_isValid(&proof_of_key->e);
    if (r != 1)
    {
        return -8;
    }

    /// s values
    // s
    mclBnFr_mul(&mul_result, &proof_of_key->e, &tau); // mul_result = e·tau
    mclBnFr_add(&proof_of_key->s, &rho, &mul_result); // s = rho + mul_result
    r = mclBnFr_isValid(&proof_of_key->s);
    if (r != 1)
    {
        return -9;
    }

    // s_id
    mclBnFr_mul(&mul_result, &proof_of_key->e, &identifier); // mul_result = e·identifier
    mclBnFr_sub(&proof_of_key->s_id, &rho_id, &mul_result); // s_id = rho_id - mul_result
    r = mclBnFr_isValid(&proof_of_key->s_id);
    if (r != 1)
    {
        return -10;
    }

    return 0;
}
